  

% Homogeneous Propagation Medium Example
%
% This example provides a simple demonstration of using k-Wave for the
% simulation and detection of the pressure field generated by an initial
% pressure distribution within a two-dimensional homogeneous propagation
% medium.
%
% author: Bradley Treeby
% date: 29th June 2009
% last update: 28th April 2017
%  
% This function is part of the k-Wave Toolbox (http://www.k-wave.org)
% Copyright (C) 2009-2017 Bradley Treeby

% This file is part of k-Wave. k-Wave is free software: you can
% redistribute it and/or modify it under the terms of the GNU Lesser
% General Public License as published by the Free Software Foundation,
% either version 3 of the License, or (at your option) any later version.
% 
% k-Wave is distributed in the hope that it will be useful, but WITHOUT ANY
% WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
% FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
% more details. 
% 
% You should have received a copy of the GNU Lesser General Public License
% along with k-Wave. If not, see <http://www.gnu.org/licenses/>. 
clear
clearvars;

% =========================================================================
% SIMULATION
% =========================================================================
%% create the computational grid
Nx = 100;           % number of grid points in the x (row) direction
Ny = 100;           % number of grid points in the y (column) direction
dx = 1e-3;        % grid point spacing in the x direction [m]
dy = 1e-3;        % grid point spacing in the y direction [m]
kgrid = kWaveGrid(Nx, dx, Ny, dy);

% define the properties of the propagation medium
medium.sound_speed = 340;  % [m/s]
medium.alpha_coeff = 0.75;  % [dB/(MHz^y cm)]
medium.alpha_power = 1.5; 

% create initial pressure distribution using makeDisc
% disc_magnitude = 5; % [Pa]
% disc_x_pos = Nx/2+45;    % [grid points]
% disc_y_pos = 65;    % [grid points]
% disc_radius = 1;    % [grid points]
% disc_1 = disc_magnitude * makeDisc(Nx, Ny, disc_x_pos, disc_y_pos, disc_radius);

%% creating a transducer to generate a sine wave.
% create the time array
kgrid.makeTime(medium.sound_speed);

% define a single source point
source.p_mask = zeros(Nx, Ny);
source.p_mask(end - Nx/4, Ny/2) = 1;

% define a time varying sinusoidal source
source_freq = 5e4;   % [Hz]
source_mag = 10;         % [Pa]
source.p = source_mag * sin(2 * pi * source_freq * kgrid.t_array);

% filter the source to remove high frequencies not supported by the grid
source.p = filterTimeSeries(kgrid, medium, source.p);

%% define both sensor array's
x_offset = 10;                 % [grid points]
width = 50;                    % [grid points]
y_mid_left = (width-20)/4 + Ny/2 - width/2;
y_mid_right = (width-20)/4 + Ny/2 + 10;
sensor.mask = zeros(Nx, Ny);
sensor.mask(x_offset, (Ny/2 - width/2 + 1:Ny/2 + width/2)) = 1;
sensor.mask(x_offset, ((Ny/2)-10):((Ny/2)+10)) = 0;

%% run the simulation
%input_args = {'RecordMovie', true, 'MovieName', 'example_movie'};
%sensor_data = kspaceFirstOrder2D(kgrid, medium, source, sensor, input_args{:});
sensor_data = kspaceFirstOrder2D(kgrid, medium, source, sensor);

sensor_left = sensor_data(1:14,:);
sensor_right = sensor_data(15:29,:);

timeStep = kgrid.dt

%% attempt at sum and beamforming
% positive is lag and negative is lead which holds for a
nmics = length(sensor_left(:,1));
aL = zeros(1,nmics);
aR = aL
aL(1) = (find(sensor_left(1,:)==max(sensor_left(1,:))))*timeStep;
aR(1) = (find(sensor_right(1,:)==max(sensor_right(1,:))))*timeStep;
for i = 2:nmics
   TOA_left = (find(sensor_left(i,:)==max(sensor_left(i,:))))*timeStep;
   aL(i) = TOA_left - aL(1)
   TOA_right = (find(sensor_right(i,:)==max(sensor_right(i,:))))*timeStep;
   aR(i) = TOA_right - aR(1)
   
end
aL(1) = 0;
aR(1) = 0;
d = dy;
c = medium.sound_speed;

for i = 1:nmics-1
   theta_left(i) =  acosd((c*aL(i+1))/(i*d));
   theta_right(i) =  acosd((c*aR(i+1))/(i*d));
end

%% draw arrow to indicate direction
paint_buffer = zeros(Nx,Ny);
theta_final_left = mean(theta_left) - 90;
theta_final_right = mean(theta_right) - 90;
end_arrow_left = real(round([x_offset+10 y_mid_left + tand(theta_final_left)/(1e03*dy)]));
end_arrow_right = real(round([x_offset+10 y_mid_right + tand(theta_final_right)/(1e03*dy)]));
paint_buffer(end_arrow_left(1),end_arrow_left(2)) = 1;
paint_buffer(end_arrow_right(1),end_arrow_right(2)) = 1;

%% fast fourier transform
startSin = find(sensor_left(7,:)>0.1)
startSin = startSin(1)

Y = fft(sensor_left(7,startSin:end));
L = length(sensor_left(7,startSin:end));
P2 = abs(Y/L);
P1 = P2(1:L/2+1);
P1(2:end-1) = 2*P1(2:end-1);
f = (1/(timeStep))*(0:(L/2))/L;

P4 = angle(Y)
P3 = P4(1:L/2+1);
index = find(f>=source_freq)
index = index(1)
[a_left, response_left] = delayCalculation(sensor_left, index)
[a_right, response_right] = delayCalculation(sensor_right, index)


%% =========================================================================
% VISUALISATION
% =========================================================================

% plot the initial pressure and sensor distribution
figure;
imagesc(kgrid.y_vec * 1e3, kgrid.x_vec * 1e3, source.p_mask + sensor.mask + paint_buffer, [-1, 1]);
colormap(getColorMap);
ylabel('x-position [mm]');
xlabel('y-position [mm]');
axis image;

% plot the simulated sensor data
% figure;
% imagesc(sensor_data, [-1, 1]);
% colormap(getColorMap);
% ylabel('Sensor Position');
% xlabel('Time Step');
% colorbar;
% 
% % plot the mesh value
% figure;
% mesh(sensor_data);
% ylabel("Sensor Position")
% xlabel("Time step")

figure
subplot(2,2,1)
imagesc(sensor_left, [-1, 1]);
colormap(getColorMap);
ylabel('Sensor Position');
xlabel('Time Step');
title("Array left");
colorbar;

subplot(2,2,3)
imagesc(sensor_right, [-1, 1]);
colormap(getColorMap);
ylabel('Sensor Position');
xlabel('Time Step');
title("Array right");
colorbar;

subplot(2,2,2)
plot(response_left)
xlabel('Time Step')
ylabel('Amplitude measured')
title("Left array response")

subplot(2,2,4)
plot(response_right)
xlabel('Time Step')
ylabel('Amplitude measured')
title("Right array response")

figure
subplot(2,1,1)
plot(f,P1) 
title('Single-Sided Amplitude Spectrum of X(t)')
xlabel('f (Hz)')
ylabel('|P1(f)|')
subplot(2,1,2)
plot(f,P3) 
xlabel('f (Hz)')
ylabel('Angle(P1(f))')